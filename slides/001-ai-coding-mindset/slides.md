---
title: AIコーディングの心構え
theme: white
highlightTheme: github
revealOptions:
  transition: slide
  controls: true
  progress: true
  history: true
  center: true
  width: 1200
  height: 800
---

<style>
.reveal h1 { 
  font-size: 2.2em; 
  line-height: 1.2; 
}

.reveal h2 { 
  font-size: 1.8em; 
  line-height: 1.3; 
}

.reveal h3 { 
  font-size: 1.4em; 
  line-height: 1.4; 
}

.reveal p, .reveal li { 
  font-size: 0.9em; 
  line-height: 1.6;
  text-align: left;
  max-width: 90%;
  margin: 0 auto;
}

.reveal .slides section {
  text-align: left;
  padding: 20px;
}

.reveal .slides section h1,
.reveal .slides section h2 {
  text-align: center;
  margin-bottom: 1em;
}

/* Force override Reveal.js white theme list styles */
.reveal .slides > section ol, 
.reveal .slides > section dl, 
.reveal .slides > section ul,
.reveal .slides > section > ol, 
.reveal .slides > section > dl, 
.reveal .slides > section > ul {
  display: block !important;
  text-align: left !important;
  margin: 1em auto !important;
  width: 90% !important;
  max-width: none !important;
}

/* Additional specificity for nested lists */
.reveal ol,
.reveal dl,
.reveal ul {
  display: block !important;
  text-align: left !important;
  margin: 1em auto !important;
  width: 90% !important;
}

.reveal .slides section ul,
.reveal .slides > section ul {
  margin-left: 0 !important;
}

.reveal strong {
  color: #e74c3c;
  font-weight: bold;
}

.reveal code {
  background: #f8f9fa;
  padding: 2px 6px;
  border-radius: 3px;
  color: #e74c3c;
}
</style>

# AIコーディングの心構え講義

---

## オープニング：三つの軸で考える

---

### 問いかけ

「今日は最初に警告から始めます。  
AIを使うと、考えなくても動くコードが手に入ります。  
それはとても便利ですが、同時に危険なものでもあります。」

---

### 三つの軸の導入

エンジニアリングの本質は、この3つを決めることです：

1. **コンテクスト** - 仕事を取り巻く状況・背景・制約
2. **スコープ** - どこまで作るのか、範囲・境界はどこか
3. **粒度** - どのくらいの細かさで設計・実装するのか

---

### AIと10倍の法則

AIを使うと10倍速く仕事を進めることができますが、これらを正しく定義できないと、AIを使っても『10倍速く間違った方向に進む』だけです。

でも、ここに大きなチャンスがあります。

---

### パラメータとしての3つの軸

**これらの3つの軸こそ、人間が自由に指定できる『パラメータ』です。**

同じ「ユーザー管理」でも、コンテクスト・スコープ・粒度を変えれば、全く違う成果物を瞬時に生成できる。

これまでベテランエンジニアが頭の中でやっていた『調整』を、AIに対して明示的に指示できる。

---

### 最強の相棒

つまり、この3つを使いこなせることができれば、AIは最強の相棒になります。

---

## 第1部：LLMの本質 - 3つの軸を持たない相手

---

### トークン予測マシンとしての仕組み

「LLMは『次に来る確率の高い単語を予測する』マシンです。

重要なのは、LLMには：

- **コンテクスト**の理解がない（なぜ必要かわからない）
- **スコープ**の概念がない（どこまでやるか判断できない）
- **粒度**の感覚がない（適切な詳細度がわからない）

新入社員の初日より白紙です。」

---

### 3つの軸の欠如がもたらす問題

よくある指示：『ユーザー管理機能を作って』

この指示でAIが生成するコードの問題点：

- なぜ作るか不明 → 過剰な機能や不足が起きる
- どこまで作るか不明 → 認証は？権限管理は？監査ログは？
- どのレベルか不明 → DB設計から？API実装だけ？

**スコープが曖昧だと、後で必ず破綻します。**

---

## 第2部：コンテクスト - なぜ作るのか

---

### 3つの軸の依存関係

「3つの軸には順序があります：

**コンテクスト → スコープ → 粒度**

なぜこれを作るか（コンテクスト）がわからなければ、どこまで作るか（スコープ）を決められない。

どこまで作るかが決まらなければ、どの細かさで作るか（粒度）も決まらない。

上流が曖昧だと、下流は全部曖昧になります。」

---

### ベテランが持つ「見えない地図」

「コンテクストとは『仕事を取り巻く状況・背景・制約』です。

ベテラン同士が『いい感じに』で通じるのは、この地図を共有しているから。

でもこれを共有していない相手（新人やAI）には、毎回、地図を渡す必要があります。」

---

### コンテクストの6要素

最低限伝えるべきコンテクストです：

1. **目的** - 何を達成したいのか
2. **背景** - なぜ今これが必要か
3. **制約** - 技術・時間・予算の制限
4. **既存** - すでにあるシステムとの関係
5. **利用者** - 誰が使い、誰が保守するか
6. **品質基準** - 何をもって完成とするか

---

### コンテクスト6要素の具体例

「TODO管理アプリを作る」という同じ要求でも：

**ケース1: 個人の学習用**
1. **目的**: Reactの基礎を学ぶ
2. **背景**: フロントエンド転職のポートフォリオ用
3. **制約**: 無料で動かせる範囲、1週間で完成
4. **既存**: なし（スクラッチから開発）
5. **利用者**: 自分だけ、採用担当者が見る
6. **品質基準**: 基本機能が動けばOK

→ **結果**: シンプルなローカルストレージ利用

---

### コンテクスト6要素の具体例（続き）

**ケース2: スタートアップのMVP**
1. **目的**: チーム作業の効率化を実証
2. **背景**: 投資家へのデモが2週間後
3. **制約**: AWS無料枠、エンジニア2名
4. **既存**: SlackのWebhookと連携必須
5. **利用者**: 5-10名のチーム、非エンジニア含む
6. **品質基準**: 基本的なセキュリティとUX

→ **結果**: Firebase + React + Slack統合

---

### コンテクスト6要素の具体例（続き2）

**ケース3: 大企業の社内ツール**
1. **目的**: 全社5000人の業務標準化
2. **背景**: 働き方改革で残業削減が必須
3. **制約**: 既存のオンプレ環境、IE11対応必須
4. **既存**: 10年前のレガシーシステムと連携
5. **利用者**: 全社員（ITリテラシー様々）
6. **品質基準**: 99.9%稼働、監査対応必須

→ **結果**: Java + Spring + Oracle、段階移行

**同じ「TODO管理」でも全く別物になります**

---

### スコープ判断への影響

**コンテクストが不明だと、スコープを切れません。**

例：『ログイン機能を作る』

- B2Cサービス → ソーシャルログイン必須
- 社内システム → AD連携が必要
- 医療システム → 多要素認証・監査ログ必須

コンテクスト次第で、スコープが全く変わる。

---

## 第3部：スコープ - どこまで作るのか

---

### スコープとは境界線を引くこと

「スコープは『今回やること・やらないこと』の線引きです。

経験の浅いエンジニアの典型的な失敗：

1. 全部一度に作ろうとして破綻
2. 必要な機能を見落として後から追加
3. 依存関係を考えずに作って手戻り

**AIも全く同じミスをします。**
なぜなら、『全体像』が見えていないから。」

---

### スコープの切り方

プロのスコープの切り方を教えます：

1. **機能分解** - 大きな機能を小さく分ける  
   『ECサイト』→『商品一覧』『カート』『決済』

2. **優先順位** - MVPから始める  
   『まず見るだけ』→『次に買える』→『最後に推薦』

3. **依存関係** - 作る順序を考える  
   『認証』→『ユーザー管理』→『権限管理』

---

### スコープの明示による違い

同じ『商品一覧』でも、スコープ次第で別物になります。

**スコープ小：**  
『商品名と価格を10件表示するだけ。ページングなし』

**スコープ中：**  
『検索・フィルタ・ソート機能付き。ページング対応』

**スコープ大：**  
『在庫連携、レコメンド、お気に入り機能まで含む』

**スコープを明示しないと、AIは勝手に判断します。**

---

## 第4部：粒度 - どのレベルで作るのか

---

### 粒度とは抽象度のレベル

粒度とは『どのくらい細かく分けるか』です。

**粗い粒度（抽象的）** - アーキテクチャ設計、技術選定  
**中間の粒度（実装）** - 具体的なコード、テストケース  
**細かい粒度（詳細）** - バグ修正、リファクタリング

---

### 粒度の詳細

**粗い粒度（抽象的）**
- アーキテクチャ設計、技術選定、インターフェース定義

**中間の粒度（実装）**
- 具体的なコード、エラーハンドリング、テストケース

**細かい粒度（詳細）**
- 特定のバグ修正、パフォーマンスチューニング、リファクタリング

---

### 粒度の違いを理解する - 同じ「ログイン機能」でも

新人が混乱しやすいのが粒度の違いです。  
同じ「ログイン機能」でも、粒度によって議論や作業が全く変わります。

---

### 粗い粒度での議論（設計レベル）

```
「認証方式はJWTとセッションどちらにする？」
「認証サービスは別マイクロサービスにする？」
「OAuth2.0プロバイダーは何を使う？」
```

→ **システム全体への影響を考える**  
→ 技術選定、アーキテクチャの決定  
→ 後から変更すると影響範囲が大きい

---

### 中間の粒度での実装

```javascript
// 実際のコードを書く
async function login(email, password) {
  const user = await User.findByEmail(email);
  if (!user || !bcrypt.compare(password, user.hash)) {
    throw new AuthError('Invalid credentials');
  }
  return generateToken(user);
}
```

→ **具体的な処理の流れを実装**  
→ エラーハンドリング、テストケースも考慮

---

### 細かい粒度での調整

```
「パスワード間違いの時、0.5秒遅延を入れる」
「ログのフォーマットをJSON形式に統一」
「エラーメッセージの文言を修正」
```

→ **細部の調整、最適化**  
→ UXの改善、セキュリティの強化  
→ 既存の動作を壊さないように注意

---

### 粒度を間違えるとどうなるか

新人がやりがちな粒度のミス：

1. **詳細に入りすぎる** - 設計段階で実装の細部にこだわる
2. **抽象的すぎる** - 実装段階で『なんとかする』で済ます  
3. **粒度を行き来できない** - 全体像と詳細を結びつけられない

**これらの能力は、失敗を通じてしか身につきません。**  
AIに頼りすぎると、この学習機会を失います。

---

### 粒度の正しい進め方 - 段階的アプローチ

**重要な原則：最終的には細かい粒度まで必要だが、順序が大切**

```
1. 粗い粒度で全体像を決める
   ↓
2. 中間の粒度で実装する
   ↓
3. 細かい粒度で調整する
```

**なぜこの順序が重要か？**
- 最初から細部にこだわると、大局を見失う
- 「木を見て森を見ず」状態になる
- 後から大きな設計変更が必要になり、手戻りが発生

---

### 粒度のアンチパターン - 避けるべき失敗例

**❌ 悪い例：いきなり細部から始める**
```
「ログのタイムスタンプはUTCにする？JST？」
「エラーコードは4桁？5桁？」
→ そもそも認証方式が決まってない！
```

**✅ 良い例：段階的に詳細化**
```
1. まず：「認証はJWTで行く」（粗い）
2. 次に：「JWT実装を書く」（中間）
3. 最後：「トークン有効期限は24時間」（細かい）
```

**粗い粒度で決めるべきことに集中してから、細部に進む**

---

### 実践：粒度を意識した指示

**粗い粒度（設計レベル）：**  
『マイクロサービス化を検討している。認証サービスの設計案を3パターン提示して』

**中間の粒度（実装レベル）：**  
『この設計書に基づいて、JWT認証のミドルウェアを実装して』

**細かい粒度（修正レベル）：**  
『auth.jsの42行目、トークン有効期限を環境変数から読むように修正』

粒度を明示することで、期待する成果物が得られます。

---

## 第4.5部：コンテクストの自動化と人間の役割

---

### AIにコードベースを読ませれば解決？

実は、既存のコードベース全体をAIに読み込ませれば、技術的なコンテクストの多くは自動的に把握できます。

最近のAIツールは：
- プロジェクト構造を理解できる
- 使用されているライブラリを認識できる
- コーディング規約をある程度推測できる

じゃあ、人間は不要になるのか？

**答えはNOです。**

---

### コードに書かれていないもの

コードベースを読んでも分からないものがあります：

1. **なぜこの設計にしたのか**
   - 他の選択肢を検討した結果なのか
   - 一時的な妥協なのか
   - 将来の拡張を見据えているのか

2. **ビジネス上の制約**
   - 『この機能は売上の7割を占める重要顧客のため』
   - 『法規制の変更に備えて柔軟に作っている』
   - 『3ヶ月後に全面リニューアル予定』

---

### 人間の新しい役割

つまり、AIコーディング時代の人間の役割は：

**技術的な指示** → AIが既存コードから学習可能  
**文脈の補完** → 人間にしかできない

例えば：  
『この認証機能は、来月のSOC2監査のために作っている。監査官が見ることを前提に、ログを詳細に、エラーメッセージは曖昧に（セキュリティのため）』

この種の情報は、100万行のコードを読んでも出てこない。

**あなたの仕事は、AIに『なぜ』を伝えること。**

---

## 第5部：AIを使った意識的な成長

---

### 便利さの罠と成長の機会

AIを使えば、3つの軸を考えなくても『なんとなく動くもの』が作れてしまう。

これが罠です。

本来なら：  
失敗 → なぜ失敗したか考える → 3つの軸の重要性に気づく

AIを使うと：  
適当な指示 → なんとなく動く → 『できた』と錯覚 → 何も学ばない

**でも、意識的に使えば逆転できます。**

---

### 新人の視点を活かす逆転の発想

上司から受けた曖昧な指示を思い出してください：

- 『いい感じにやっといて』
- 『例のあれ、よろしく』
- 『なんかエラー出てるから直して』

あの時、本当は何を聞きたかったですか？

- いい感じの**基準**は？（→コンテクスト不足）
- どこまで**自分で決めていい**？（→スコープ不明）
- どのレベルで**対応すべき**？（→粒度不明）

---

### 困った指示の裏返し

この『知りたかったこと』こそ、AIに伝えるべき情報です。

つまり：  
**困った指示の裏返し ＝ 良いプロンプト**

あなたが上司からもらいたかった指示が、そのままAIへの理想的なプロンプトになります。

---

### 高速失敗学習法

AIを使った意識的な学習方法：

1. **あえて曖昧な指示を出す** → 『ユーザー管理作って』
2. **結果を3つの軸で分析** → 何が不足していたか
3. **改善して再指示** → より明確なプロンプト作成
4. **違いを観察し、学ぶ** → パターンを身体に覚えさせる

これを繰り返せば、ベテランの10年分の『判断力』が身につく。

---

## クロージング：エンジニアとしての成長

---

### 3つのメッセージ

1. **3つの軸は、あなたにしか決められない**  
   これらはAIの責任範囲ではない - だからこそ、人間の価値がある

2. **AIは鏡である**  
   曖昧な指示には曖昧な結果、明確な指示には明確な結果  
   あなたの思考の質を映し出す

3. **意識的に失敗し、意識的に学ぶ**  
   AIの便利さに流されず、毎回『なぜこうなったか』を考える  
   それが成長への最短経路

---

### エンジニアリングの本質

プログラミング35年の経験から言えることは、  
**ツールは変わっても、エンジニアリングの本質は変わらない**  
ということです。

コンテクスト・スコープ・粒度。  
この3つを押さえれば、どんな時代でも生き残れます。

---

### Q&A

質問をどうぞ。  
特に『スコープで悩んだ経験』があれば、一緒に考えてみましょう。

---

## ありがとうございました

---